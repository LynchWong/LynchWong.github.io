<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Swift," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="String 是例如”hello, world”,”albatross”这样的有序的 Character (字符)类型的值的集合,通过 String 类型来表示。Swift 的 String 和 Character 类型提供了一个快速的,兼容 Unicode 的方式来处理代码中的文本。创建和操作字符串的语法与 C 语言中字符串操作相似,轻量并且易读。字符串连接操作只需要简单地通过 + 符号将两个字">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift之字符串和字符">
<meta property="og:url" content="http://lynchwong.com/2015/01/25/Swift之字符串和字符/index.html">
<meta property="og:site_name" content="Nobodyknows+ 2.0">
<meta property="og:description" content="String 是例如”hello, world”,”albatross”这样的有序的 Character (字符)类型的值的集合,通过 String 类型来表示。Swift 的 String 和 Character 类型提供了一个快速的,兼容 Unicode 的方式来处理代码中的文本。创建和操作字符串的语法与 C 语言中字符串操作相似,轻量并且易读。字符串连接操作只需要简单地通过 + 符号将两个字">
<meta property="og:image" content="http://lynchwong.com/img/iOSStringsandCharacters/1.png">
<meta property="og:image" content="http://lynchwong.com/img/iOSStringsandCharacters/2.png">
<meta property="og:image" content="http://lynchwong.com/img/iOSStringsandCharacters/3.png">
<meta property="og:updated_time" content="2016-06-01T12:42:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Swift之字符串和字符">
<meta name="twitter:description" content="String 是例如”hello, world”,”albatross”这样的有序的 Character (字符)类型的值的集合,通过 String 类型来表示。Swift 的 String 和 Character 类型提供了一个快速的,兼容 Unicode 的方式来处理代码中的文本。创建和操作字符串的语法与 C 语言中字符串操作相似,轻量并且易读。字符串连接操作只需要简单地通过 + 符号将两个字">
<meta name="twitter:image" content="http://lynchwong.com/img/iOSStringsandCharacters/1.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>

  <title> Swift之字符串和字符 | Nobodyknows+ 2.0 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Nobodyknows+ 2.0</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">iOS、Go</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Swift之字符串和字符
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2015-01-25T20:19:35+08:00" content="2015-01-25">
              2015-01-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/01/25/Swift之字符串和字符/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/01/25/Swift之字符串和字符/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
              &nbsp; | &nbsp;
              <span class="page-pv"><i class="fa fa-file-o"></i>
              <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
              </span>
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>String 是例如”hello, world”,”albatross”这样的有序的 Character (字符)类型的值的集合,通过 String 类型来表示。Swift 的 String 和 Character 类型提供了一个快速的,兼容 Unicode 的方式来处理代码中的文本。创建和操作字符串的语法与 C 语言中字符串操作相似,轻量并且易读。字符串连接操作只需要简单地通过 + 符号将两个字符串相连即可。与 Swift 中其他值一样,能否更改字符串的值,取决于其被定义为常量还是变量。尽管语法简易,但 String 类型是一种快速、现代化的字符串实现。每一个字符串都是由编码无关的 Unicode 字符组成,并支持访问字符的多种 Unicode 表示形式(representations)。 你也可以在常量、变量、字面量和表达式中进行字符串插值操作,这可以帮助你轻松创建用于展示、存储和打印的自定义字符串。</p>
<p>注意:Swift 的 String 类型与 Foundation NSString 类进行了无缝桥接。就像 AnyObject 类型中提到的一样,在使用 Cocoa 中的 Foundation 框架时,您可以将创建的任何字符串的值转换成 NSString,并调用任意的 NSString API。您也可以在任意要求传入 NSString 实例作为参数的 API 中用 String 类型的值代替。更多关于在 Foundation 和 Cocoa 中使用 String 的信息请查看 Using Swift with Cocoa and Objective-C。</p>
<h2 id="字符串字面量-String-Literals"><a href="#字符串字面量-String-Literals" class="headerlink" title="字符串字面量(String Literals)"></a>字符串字面量(String Literals)</h2><p>您可以在您的代码中包含一段预定义的字符串值作为字符串字面量。字符串字面量是由双引号 ( “” ) 包裹着的具有固定顺序的文本字符集。字符串字面量可以用于为常量和变量提供初始值:</p>
<pre><code>let someString = &quot;Some string literal value&quot;
</code></pre><p>注意 someString 常量通过字符串字面量进行初始化,Swift 会推断该常量为 String 类型。</p>
<p>注意:更多关于在字符串字面量中使用特殊字符的信息,请查看 字符串字面量的特殊字符。</p>
<h2 id="初始化空字符串-Initializing-an-Empty-String"><a href="#初始化空字符串-Initializing-an-Empty-String" class="headerlink" title="初始化空字符串 (Initializing an Empty String)"></a>初始化空字符串 (Initializing an Empty String)</h2><p>要创建一个空字符串作为初始值,可以将空的字符串字面量赋值给变量,也可以初始化一个新的 String 实例:</p>
<pre><code>var emptyString = &quot;&quot; // 空字符串字面量
var anotherEmptyString = String() // 初始化方法
// 两个字符串均为空并等价。
</code></pre><p>您可以通过检查其 Boolean 类型的 isEmpty 属性来判断该字符串是否为空:</p>
<pre><code>if emptyString.isEmpty {
    println(&quot;Nothing to see here&quot;)
}
// 打印 &quot;Nothing to see here&quot;
</code></pre><h2 id="字符串可变性-String-Mutability"><a href="#字符串可变性-String-Mutability" class="headerlink" title="字符串可变性 (String Mutability)"></a>字符串可变性 (String Mutability)</h2><p>您可以通过将一个特定字符串分配给一个变量来对其进行修改,或者分配给一个常量来保证其不会被修改:</p>
<pre><code>var variableString = &quot;Horse&quot;
variableString += &quot; and carriage&quot;
// variableString 现在为 &quot;Horse and carriage&quot;

let constantString = &quot;Highlander&quot;
constantString += &quot; and another Highlander&quot;
// 这会报告一个编译错误 (compile-time error) - 常量字符串不可以被修改。
</code></pre><p>注意:在 Objective-C 和 Cocoa 中,您需要通过选择两个不同的类( NSString 和 NSMutableString )来指定字符串是否可以被修改。</p>
<h2 id="字符串是值类型-Strings-Are-Value-Types"><a href="#字符串是值类型-Strings-Are-Value-Types" class="headerlink" title="字符串是值类型(Strings Are Value Types)"></a>字符串是值类型(Strings Are Value Types)</h2><p>Swift 的 String 类型是值类型。如果您创建了一个新的字符串,那么当其进行常量、变量赋值操作,或在函数/方法中传递时,会进行值拷贝。任何情况下,都会对已有字符串值创建新副本,并对该新副本进行传递或赋值操作。值类型在结构体和枚举是值类型中进行了详细描述。</p>
<p>注意:与 Cocoa 中的 NSString 不同,当您在 Cocoa 中创建了一个 NSString 实例,并将其传递给一个函数/方法,或者赋值给一个变量,您传递或赋值的是该 NSString 实例的一个引用,除非您特别要求进行值拷贝,否则字符串不会生成新的副本来进行赋值操作。</p>
<p>Swift 默认字符串拷贝的方式保证了在函数/方法中传递的是字符串的值。很明显无论该值来自于哪里,都是您独自拥有的。您可以确信传递的字符串不会被修改,除非你自己去修改它。</p>
<p>在实际编译时,Swift 编译器会优化字符串的使用,使实际的复制只发生在绝对必要的情况下,这意味着您将字符串作为值类型的同时可以获得极高的性能。</p>
<h2 id="使用字符-Working-with-Characters"><a href="#使用字符-Working-with-Characters" class="headerlink" title="使用字符(Working with Characters)"></a>使用字符(Working with Characters)</h2><p>您可通过 for-in 循环来遍历字符串中的 characters 属性来获取每一个字符的值:</p>
<pre><code>for character in &quot;Dog!?&quot;.characters {
    print(character)
}
// D
// o
// g
// !
// ?
</code></pre><p>for-in 循环在 For Loops 中进行了详细描述。</p>
<p>另外,通过标明一个 Character 类型并用字符字面量进行赋值,可以建立一个独立的字符常量或变量:</p>
<pre><code>let exclamationMark: Character = &quot;!&quot;
</code></pre><p>字符串可以通过传递一个值类型为 Character 的数组作为自变量来初始化:</p>
<pre><code>let catCharacters: [Character] = [&quot;C&quot;, &quot;a&quot;, &quot;t&quot;, &quot;!&quot;, &quot;?&quot;]
let catString = String(catCharacters)
print(catString)
// 打印输出:&quot;Cat!?&quot;
</code></pre><h2 id="连接字符串和字符-Concatenating-Strings-and-Characters"><a href="#连接字符串和字符-Concatenating-Strings-and-Characters" class="headerlink" title="连接字符串和字符 (Concatenating Strings and Characters)"></a>连接字符串和字符 (Concatenating Strings and Characters)</h2><p>字符串可以通过加法运算符( + )相加在一起(或称“连接”)创建一个新的字符串:</p>
<pre><code>let string1 = &quot;hello&quot;
let string2 = &quot; there&quot;
var welcome = string1 + string2
// welcome 现在等于 &quot;hello there&quot;
</code></pre><p>您也可以通过加法赋值运算符 ( += ) 将一个字符串添加到一个已经存在字符串变量上:</p>
<pre><code>var instruction = &quot;look over&quot; instruction += string2
// instruction 现在等于 &quot;look over there&quot;
</code></pre><p>您可以用 append() 方法将一个字符附加到一个字符串变量的尾部:</p>
<pre><code>let exclamationMark: Character = &quot;!&quot;
welcome.append(exclamationMark)
// welcome 现在等于 &quot;hello there!&quot;
</code></pre><p>注意:您不能将一个字符串或者字符添加到一个已经存在的字符变量上,因为字符变量只能包含一个字符。</p>
<h2 id="字符串插值-String-Interpolation"><a href="#字符串插值-String-Interpolation" class="headerlink" title="字符串插值 (String Interpolation)"></a>字符串插值 (String Interpolation)</h2><p>字符串插值是一种全新的构建字符串的方式,可以在其中包含常量、变量、字面量和表达式。您插入的字符串字面量的每一项都被包裹在以反斜线为前缀的圆括号中:</p>
<pre><code>let multiplier = 3
let message = &quot;\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)&quot;
// message is &quot;3 times 2.5 is 7.5&quot;
</code></pre><p>在上面的例子中,multiplier 作为 (multiplier) 被插入到一个字符串字面量中。当创建字符 串执行插值计算时此占位符会被替换为 multiplier 实际的值。</p>
<p>multiplier 的值也作为字符串中后面表达式的一部分。该表达式计算 Double(multiplier) <em> 2.5 的值并将结果 (7.5) 插入到字符串中。在这个例子中,表达式写为 (Double(multiplier) </em> 2.5)并包含在字符串字面量中。</p>
<p>注意:您插值字符串中写在括号中的表达式不能包含非转义双引号 (“) 和反斜杠 () 并且不能包含回车或换行符。</p>
<h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>Unicode 是一个国际标准,用于文本的编码和表示。 它使您可以用标准格式表示来自任意语言几乎所有的字 符,并能够对文本文件或网页这样的外部资源中的字符进行读写操作。 Swift 的 String 和 Character 类型是完 全兼容 Unicode 标准的。</p>
<h3 id="Unicode-标量-Unicode-Scalars"><a href="#Unicode-标量-Unicode-Scalars" class="headerlink" title="Unicode 标量(Unicode Scalars)"></a>Unicode 标量(Unicode Scalars)</h3><p>Swift 的 String 类型是基于 Unicode 标量 建立的。 Unicode 标量是对应字符或者修饰符的唯一的21位数 字,例如 U+0061 表示小写的拉丁字母( LATIN SMALL LETTER A )(“ a “), U+1F425 表示小鸡表情( FRON T-FACING BABY CHICK ) (“ ? “)。</p>
<p>注意: Unicode 码位(code poing) 的范围是 U+0000 到 U+D7FF 或者 U+E000 到 U+10FFFF 。Unicode 标量不包括 Unicode 代理项(surrogate pair) 码位,其码位范围是 U+D800 到 U+DFFF 。</p>
<p>注意不是所有的21位 Unicode 标量都代表一个字符,因为有一些标量是留作未来分配的。已经代表一个典型字符 的标量都有自己的名字,例如上面例子中的 LATIN SMALL LETTER A 和 FRONT-FACING BABY CHICK 。</p>
<h3 id="字符串字面量的特殊字符-Special-Characters-in-String-Literals"><a href="#字符串字面量的特殊字符-Special-Characters-in-String-Literals" class="headerlink" title="字符串字面量的特殊字符 (Special Characters in String Literals)"></a>字符串字面量的特殊字符 (Special Characters in String Literals)</h3><p>字符串字面量可以包含以下特殊字符:</p>
<ul>
<li>转义字符 \0 (空字符)、 \ (反斜线)、 \t (水平制表符)、 \n (换行符)、 \r (回车符)、 \” (双引号)、 \’ (单引 号)。</li>
<li>Unicode 标量,写成 \u{n} (u为小写),其中 n 为任意一到八位十六进制数且可用的 Unicode 位码。</li>
</ul>
<p>下面的代码为各种特殊字符的使用示例。 wiseWords 常量包含了两个双引号。 dollarSign 、 blackHeart 和 s parklingHeart 常量演示了三种不同格式的 Unicode 标量:</p>
<p>let wiseWords = “\”Imagination is more important than knowledge\” - Einstein” // “Imageination is more important than knowledge” - Enistein<br>let dollarSign = “\u{24}” // $, Unicode 标量 U+0024<br>let blackHeart = “\u{2665}” // ?, Unicode 标量 U+2665<br>let sparklingHeart = “\u{1F496}” // ?, Unicode 标量 U+1F496</p>
<h3 id="可扩展的字形群集-Extended-Grapheme-Clusters"><a href="#可扩展的字形群集-Extended-Grapheme-Clusters" class="headerlink" title="可扩展的字形群集(Extended Grapheme Clusters)"></a>可扩展的字形群集(Extended Grapheme Clusters)</h3><p>每一个 Swift 的 Character 类型代表一个可扩展的字形群。一个可扩展的字形群是一个或多个可生成人类可读的字符 Unicode 标量的有序排列。举个例子,字母 é 可以用单一的 Unicode 标量 é (<br>LATIN SMALL LETTERE WITH ACUTE , 或者 U+00E9 )来表示。然而一个标准的字母 é 或者 U+0065 ) 加上一个急促重音( COMBINING ACTUE ACCENT )的标量( U+0301 ),这样一对标量就表示了同样的字母 é 。 这个急促重音的标量形象的将 e 转换成了 é 。</p>
<p>在这两种情况中,字母 é 代表了一个单一的 Swift 的 Character 值,同时代表了一个可扩展的字形群。 在第一种情况,这个字形群包含一个单一标量;而在第二种情况,它是包含两个标量的字形群:</p>
<pre><code>let eAcute: Character = &quot;\u{E9}&quot; // é
let combinedEAcute: Character = &quot;\u{65}\u{301}&quot; // e 后面加上 ?
// eAcute 是 é, combinedEAcute 是 e?
</code></pre><p>可扩展的字符群集是一个灵活的方法,用许多复杂的脚本字符表示单一的 Character 值。 例如,来自朝鲜语字母表的韩语音节能表示为组合或分解的有序排列。在 Swift 都会表示为同一个单一的 Character 值:</p>
<pre><code>let precomposed: Character = &quot;\u{D55C}&quot; // ?
let decomposed: Character = &quot;\u{1112}\u{1161}\u{11AB}&quot; // ?, ?, ?
// precomposed 是 ?, decomposed 是 ???
</code></pre><p>可拓展的字符群集可以使包围记号(例如 COMBINING ENCLOSING CIRCLE 或者 U+20DD )的标量包围其他 Unicode 标量,作为一个单一的 Character 值:</p>
<pre><code>let enclosedEAcute: Character = &quot;\u{E9}\u{20DD}&quot;
// enclosedEAcute 是 é?
</code></pre><p>局部的指示符号的 Unicode 标量可以组合成一个单一的 Character 值,例如 REGIONAL INDICATOR SYMBOL LETTER U (U + 1F1FA) 和 REGIONAL INDICATOR SYMBOL LETTER S (U + 1F1F8):</p>
<pre><code>let regionalIndicatorForUS: Character = &quot;\u{1F1FA}\u{1F1F8}&quot;
// regionalIndicatorForUS 是 ??
</code></pre><h2 id="计算字符数量-Counting-Characters"><a href="#计算字符数量-Counting-Characters" class="headerlink" title="计算字符数量 (Counting Characters)"></a>计算字符数量 (Counting Characters)</h2><p>如果想要获得一个字符串中 Character 值的数量,可以使用字符串的 characters 属性的 count 属性:</p>
<pre><code>let unusualMenagerie = &quot;Koala ?, Snail ?, Penguin ?, Dromedary ?&quot;
print(&quot;unusualMenagerie has \(unusualMenagerie.characters.count) characters&quot;)
// 打印输出 &quot;unusualMenagerie has 40 characters&quot;
</code></pre><p>注意在 Swift 中,使用可拓展的字符群集作为 Character 值来连接或改变字符串时,并不一定会更改字符串的字 符数量。</p>
<p>例如,如果你用四个字符的单词 cafe 初始化一个新的字符串,然后添加一个 COMBINING ACTUE ACCENT (U + 0301) 作为字符串的结尾。最终这个字符串的字符数量仍然是 4 ,因为第四个字符是 e ,而不是 e :</p>
<p>var word = “cafe”<br>print(“the number of characters in (word) is (word.characters.count)”) // 打印输出 “the number of characters in cafe is 4”<br>word += “\u{301}” // COMBINING ACUTE ACCENT, U+0301<br>print(“the number of characters in (word) is (word.characters.count)”) // 打印输出 “the number of characters in café is 4”</p>
<p>注意:可扩展的字符群集可以组成一个或者多个 Unicode 标量。这意味着不同的字符以及相同字符的不同表示方式可能需要不同数量的内存空间来存储。所以 Swift 中的字符在一个字符串中并不一定占用相同的内存空间数量。因此在没有获取字符串的可扩展的字符群的范围时候,就不能计算出字符串的字符数量。如果您正在处理一个长字符串,需要注意 characters 属性必须遍历全部的 Unicode 标量,来确定字符串的字符数量。</p>
<p>另外需要注意的是通过 characters 属性返回的字符数量并不总是与包含相同字符的 NSString 的 length 属性相同。 NSString 的 length 属性是利用 UTF-16 表示的十六位代码单元数字,而不是 Unicode 可扩展的字符群集。作为佐证,当一个 NSString 的 length 属性被一个Swift的 String 值访问时,实际上是调用了 utf16Count。</p>
<h2 id="访问和修改字符串-Accessing-and-Modifying-a-String"><a href="#访问和修改字符串-Accessing-and-Modifying-a-String" class="headerlink" title="访问和修改字符串 (Accessing and Modifying a String)"></a>访问和修改字符串 (Accessing and Modifying a String)</h2><p>你可以通过字符串的属性和方法来访问和读取它,当然也可以用下标语法完成。</p>
<h3 id="字符串索引-String-Indices"><a href="#字符串索引-String-Indices" class="headerlink" title="字符串索引 (String Indices)"></a>字符串索引 (String Indices)</h3><p>每一个 String 值都有一个关联的索引(index)类型, String.Index ,它对应着字符串中的每一个 Character 的位置。</p>
<p>前面提到,不同的字符可能会占用不同数量的内存空间,所以要知道 Character 的确定位置,就必须从 String 开头遍历每一个 Unicode 标量直到结尾。因此,Swift 的字符串不能用整数(integer)做索引。</p>
<p>使用 startIndex 属性可以获取一个 String 的第一个 Character 的索引。使用 endIndex 属性可以获取最后一个 Character 的后一个位置的索引。因此, endIndex 属性不能作为一个字符串的有效下标。如果 String 是空串, startIndex 和 endIndex 是相等的。</p>
<p>通过调用 String.Index 的 predecessor() 方法,可以立即得到前面一个索引,调用 successor() 方法可以立即得到后面一个索引。任何一个 String 的索引都可以通过锁链作用的这些方法来获取另一个索引,也可以调用 ancedBy(_:) 方法来获取。但如果尝试获取出界的字符串索引,就会抛出一个运行时错误。</p>
<p>你可以使用下标语法来访问 String 特定索引的 Character 。</p>
<pre><code>let greeting = &quot;Guten Tag!&quot;
greeting[greeting.startIndex]
// G greeting[greeting.endIndex.predecessor()]

// !
greeting[greeting.startIndex.successor()]
// u
let index = greeting.startIndex.advancedBy(7) greeting[index]
// a
</code></pre><p>试图获取越界索引对应的 Character ,将引发一个运行时错误。</p>
<pre><code>greeting[greeting.endIndex] // error
greeting.endIndex.successor() // error
</code></pre><p>使用 characters 属性的 indices 属性会创建一个包含全部索引的范围( Range ),用来在一个字符串中访问单个字符。</p>
<pre><code>for index in greeting.characters.indices {
    print(&quot;\(greeting[index]) &quot;, terminator: &quot;&quot;)
}
// 打印输出 &quot;G u t e n T a g !&quot;
</code></pre><h3 id="插入和删除-Inserting-and-Removing"><a href="#插入和删除-Inserting-and-Removing" class="headerlink" title="插入和删除 (Inserting and Removing)"></a>插入和删除 (Inserting and Removing)</h3><p>调用 insert(_:atIndex:) 方法可以在一个字符串的指定索引插入一个字符。</p>
<pre><code>var welcome = &quot;hello&quot;
welcome.insert(&quot;!&quot;, atIndex: welcome.endIndex)
// welcome now 现在等于 &quot;hello!&quot;
</code></pre><p>调用 insertContentsOf(_:at:) 方法可以在一个字符串的指定索引插入一个字符串。</p>
<pre><code>welcome.insertContentsOf(&quot; there&quot;.characters, at: welcome.endIndex.predecessor())
// welcome 现在等于 &quot;hello there!&quot;
</code></pre><p>调用 removeAtIndex(_:) 方法可以在一个字符串的指定索引删除一个字符。</p>
<pre><code>welcome.removeAtIndex(welcome.endIndex.predecessor())
// welcome 现在等于 &quot;hello there&quot;
</code></pre><p>调用 removeRange(_:) 方法可以在一个字符串的指定索引删除一个子字符串。</p>
<pre><code>let range = welcome.endIndex.advancedBy(-6)..&lt;welcome.endIndex
welcome.removeRange(range)
// welcome 现在等于 &quot;hello&quot;
</code></pre><h2 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h2><p>Swift 提供了三种方式来比较文本值:字符串字符相等、前缀相等和后缀相等。</p>
<h3 id="字符串-字符相等-String-and-Character-Equality"><a href="#字符串-字符相等-String-and-Character-Equality" class="headerlink" title="字符串/字符相等 (String and Character Equality)"></a>字符串/字符相等 (String and Character Equality)</h3><p>字符串/字符可以用等于操作符( == )和不等于操作符( != ),详细描述在比较运算符:</p>
<pre><code>let quotation = &quot;We&apos;re a lot alike, you and I.&quot;
let sameQuotation = &quot;We&apos;re a lot alike, you and I.&quot;
if quotation == sameQuotation {
    print(&quot;These two strings are considered equal&quot;)
}
// 打印输出 &quot;These two strings are considered equal&quot;
</code></pre><p>如果两个字符串(或者两个字符)的可扩展的字形群集是标准相等的,那就认为它们是相等的。在这个情况 下,即使可扩展的字形群集是有不同的 Unicode 标量构成的,只要它们有同样的语言意义和外观,就认为它们标准相等。</p>
<p>例如, LATIN SMALL LETTER E WITH ACUTE (U + 00E9) 就是标准相等于 LATIN SMALL LETTER E (U + 0065)后面加上 COMBINING ACUTE ACCENT (U + 0301)。这两个字符群集都是表示字符 é 的有效方式,所以它们被认为是标准相等的:</p>
<pre><code>// &quot;Voulez-vous un café?&quot; 使用 LATIN SMALL LETTER E WITH ACUTE
let eAcuteQuestion = &quot;Voulez-vous un caf\u{E9}?&quot;
// &quot;Voulez-vous un cafe??&quot; 使用 LATIN SMALL LETTER E and COMBINING ACUTE ACCENT
let combinedEAcuteQuestion = &quot;Voulez-vous un caf\u{65}\u{301}?&quot;
if eAcuteQuestion == combinedEAcuteQuestion {
    print(&quot;These two strings are considered equal&quot;)
}
// 打印输出 &quot;These two strings are considered equal&quot;
</code></pre><p>相反,英语中的 LATIN CAPITAL LETTER A (U + 0041，或者 A )不等于俄语中的 CYRILLIC CAPITAL LETTERA (U + 0410， 或者 A )。两个字符看着是一样的,但却有不同的语言意义:</p>
<pre><code>let latinCapitalLetterA: Character = &quot;\u{41}&quot;
let cyrillicCapitalLetterA: Character = &quot;\u{0410}&quot;
if latinCapitalLetterA != cyrillicCapitalLetterA {
    print(&quot;These two characters are not equivalent&quot;)
}
// 打印 &quot;These two characters are not equivalent&quot;
</code></pre><p>注意: 在 Swift 中,字符串和字符并不区分区域。</p>
<h3 id="前缀-后缀相等"><a href="#前缀-后缀相等" class="headerlink" title="前缀/后缀相等"></a>前缀/后缀相等</h3><p>通过调用字符串的 hasPrefix(<em>:)/hasSuffix(</em>:) 方法来检查字符串是否拥有特定前缀/后缀,两个方法均接收一个 String 类型的参数,并返回一个布尔值。</p>
<p>下面的例子以一个字符串数组表示莎士比亚话剧《罗密欧与朱丽叶》中前两场的场景位置:</p>
<pre><code>let romeoAndJuliet = [
    &quot;Act 1 Scene 1: Verona, A public place&quot;,
    &quot;Act 1 Scene 2: Capulet&apos;s mansion&quot;,
    &quot;Act 1 Scene 3: A room in Capulet&apos;s mansion&quot;,
    &quot;Act 1 Scene 4: A street outside Capulet&apos;s mansion&quot;, &quot;Act 1 Scene 5: The Great Hall in Capulet&apos;s mansion&quot;, &quot;Act 2 Scene 1: Outside Capulet&apos;s mansion&quot;,
    &quot;Act 2 Scene 2: Capulet&apos;s orchard&quot;,
    &quot;Act 2 Scene 3: Outside Friar Lawrence&apos;s cell&quot;,
    &quot;Act 2 Scene 4: A street in Verona&quot;,
    &quot;Act 2 Scene 5: Capulet&apos;s mansion&quot;,
    &quot;Act 2 Scene 6: Friar Lawrence&apos;s cell&quot;
]
</code></pre><p>您可以调用 hasPrefix(_:) 方法来计算话剧中第一幕的场景数:</p>
<pre><code>var act1SceneCount = 0
for scene in romeoAndJuliet {
    if scene.hasPrefix(&quot;Act 1 &quot;) {
        ++act1SceneCount
    }
}
print(&quot;There are \(act1SceneCount) scenes in Act 1&quot;)
// 打印输出 &quot;There are 5 scenes in Act 1&quot;
</code></pre><p>相似地,您可以用 hasSuffix(_:) 方法来计算发生在不同地方的场景数:</p>
<pre><code>var mansionCount = 0
var cellCount = 0
for scene in romeoAndJuliet {
    if scene.hasSuffix(&quot;Capulet&apos;s mansion&quot;) {
        ++mansionCount
    } else if scene.hasSuffix(&quot;Friar Lawrence&apos;s cell&quot;) {
        ++cellCount
    }
}
print(&quot;\(mansionCount) mansion scenes; \(cellCount) cell scenes&quot;) // 打印输出 &quot;6 mansion scenes; 2 cell scenes&quot;
</code></pre><p>注意: hasPrefix(<em>:) 和 hasSuffix(</em>:) 方法都是在每个字符串中逐字符比较其可扩展的字符群集是否标准相 等,详细描述在字符串/字符相等。</p>
<h2 id="字符串的-Unicode-表示形式-Unicode-Representations-of-Strings"><a href="#字符串的-Unicode-表示形式-Unicode-Representations-of-Strings" class="headerlink" title="字符串的 Unicode 表示形式(Unicode Representations of Strings)"></a>字符串的 Unicode 表示形式(Unicode Representations of Strings)</h2><p>当一个 Unicode 字符串被写进文本文件或者其他储存时,字符串中的 Unicode 标量会用 Unicode 定义的几种编码格式编码。每一个字符串中的小块编码都被称为代码单元。这些包括 UTF-8 编码格式(编码字符串为8位的代码单元), UTF-16 编码格式(编码字符串位16位的代码单元),以及 UTF-32 编码格式(编码字符串32位的代码单元)。</p>
<p>Swift 提供了几种不同的方式来访问字符串的 Unicode 表示形式。 您可以利用 for-in 来对字符串进行遍历,从而以 Unicode 可扩展的字符群集的方式访问每一个 Character 值。 该过程在使用字符 中进行了描述。</p>
<p>另外,能够以其他三种 Unicode 兼容的方式访问字符串的值:</p>
<ul>
<li>UTF-8 代码单元集合 (利用字符串的 utf8 属性进行访问)</li>
<li>UTF-16 代码单元集合 (利用字符串的 utf16 属性进行访问)</li>
<li>21位的 Unicode 标量值集合,也就是字符串的 UTF-32 编码格式 (利用字符串的 unicodeScalars 属性进行访问)</li>
</ul>
<p>下面由 D<code>o</code>g``?(DOUBLE EXCLAMATION MARK, Unicode 标量 U+203C )和 ? (DOG FACE, Unicode 标量为 U+1F436 )组成的字符串中的每一个字符代表着一种不同的表示:</p>
<pre><code>let dogString = &quot;Dog??&quot;
</code></pre><h3 id="UTF-8-表示"><a href="#UTF-8-表示" class="headerlink" title="UTF-8 表示"></a>UTF-8 表示</h3><p>您可以通过遍历 String 的 utf8 属性来访问它的 UTF-8 表示。 其为 String.UTF8View 类型的属性, UTF8View 是无符号8位 ( UInt8 ) 值的集合,每一个 UInt8 值都是一个字符的 UTF-8 表示:</p>
<p><img src="/img/iOSStringsandCharacters/1.png" alt="alt text"></p>
<pre><code>for codeUnit in dogString.utf8 {
    print(&quot;\(codeUnit) &quot;, terminator: &quot;&quot;)
}
print(&quot;&quot;)
// 68 111 103 226 128 188 240 159 144 182
</code></pre><p>上面的例子中，前三个10进制 codeUnit 值(68, 111, 103)代表了字符D、o 和 g，他们的UTF－8表示与ASCII表示相同。接下来三个10进制 codeUnit 值(226, 128, 188)是 DOUBLE EXCLAMATION MARK 的3字节UTF－8表示。最后的四个 codeUnit 值(240, 159 144, 182)是 DOG FACE 的4字节UTF－8表示。</p>
<h3 id="UTF-16-表示"><a href="#UTF-16-表示" class="headerlink" title="UTF-16 表示"></a>UTF-16 表示</h3><p>您可以通过遍历 String 的 utf16 属性来访问它的 UTF-16 表示。 其为 String.UTF16View 类型的属性, UTF16View 是无符号16位 ( UInt16 ) 值的集合,每一个 UInt16 都是一个字符的 UTF-16 表示:</p>
<p><img src="/img/iOSStringsandCharacters/2.png" alt="alt text"></p>
<pre><code>for codeUnit in dogString.utf16 {
    print(&quot;\(codeUnit) &quot;, terminator: &quot;&quot;)
}
print(&quot;&quot;)
// 68 111 103 8252 55357 56374
</code></pre><p>同样,前三个 codeUnit 值 ( 68 , 111 , 103) 代表了字符D、o 和 g，他们的UTF－16和UTF－8 完全相同(因为这些 Unicode 标量表示 ASCII 字符)。</p>
<p>第四个 codeUnit 值 ( 8252 ) 是一个等于十六进制 203C 的的十进制值。这个代表了 DOUBLE EXCLAMATION MARK 字符的 Unicode 标量值 U+203C 。这个字符在 UTF-16 中可以用一个代码单元表示。</p>
<p>第五和第六个 codeUnit 值 ( 55357 和 56374 ) 是 DOG FACE 字符的 UTF-16 表示。 第一个值为 U+D83D (十进制值为 55357 ),第二个值为 U+DC36 (十进制值为 56374 )。</p>
<h3 id="Unicode-标量表示-Unicode-Scalars-Representation"><a href="#Unicode-标量表示-Unicode-Scalars-Representation" class="headerlink" title="Unicode 标量表示 (Unicode Scalars Representation)"></a>Unicode 标量表示 (Unicode Scalars Representation)</h3><p>您可以通过遍历 String 值的 unicodeScalars 属性来访问它的 Unicode 标量表示。其为 UnicodeScalarView 类型的属性, UnicodeScalarView 是 UnicodeScalar 的集合。 UnicodeScalar 是21位的 Unicode 代码点。</p>
<p>每一个 UnicodeScalar 拥有一个 value 属性,可以返回对应的21位数值,用 UInt32 来表示:</p>
<p><img src="/img/iOSStringsandCharacters/3.png" alt="alt text"></p>
<pre><code>for scalar in dogString.unicodeScalars {
    print(&quot;\(scalar.value) &quot;, terminator: &quot;&quot;)
}
print(&quot;&quot;)
// 68 111 103 8252 128054
</code></pre><p>前三个 UnicodeScalar 值( 68 , 111 , 103 )的 value 属性仍然代表字符 D 、 o 和 g 。 第四个 codeUnit 值( 8252 )仍然是一个等于十六进制 203C 的十进制值。这个代表了 DOUBLE EXCLAMATION MARK 字符的 Unicode 标量 U+203C 。</p>
<p>第五个 UnicodeScalar 值的 value 属性, 128054 ,是一个十六进制 1F436 的十进制表示。其等同于 DOG FACE 的 Unicode 标量 U+1F436 。</p>
<p>作为查询它们的 value 属性的一种替代方法,每个 UnicodeScalar 值也可以用来构建一个新的 String 值,比如在字符串插值中使用:</p>
<pre><code>for scalar in dogString.unicodeScalars {
    print(&quot;\(scalar) &quot;)
}
// D
// o
// g
// ?
// ?
</code></pre>
      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/images/wechat-reward-image.png" alt="Lynch Wong WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/images/alipay-reward-image.png" alt="Lynch Wong Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Swift/" rel="tag">#Swift</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/01/25/Swift之基本运算符/" rel="next" title="Swift之基本运算符">
                <i class="fa fa-chevron-left"></i> Swift之基本运算符
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/01/26/Swift之集合类型/" rel="prev" title="Swift之集合类型">
                Swift之集合类型 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="2015/01/25/Swift之字符串和字符/"
     data-title="Swift之字符串和字符"
     data-content=""
     data-url="http://lynchwong.com/2015/01/25/Swift之字符串和字符/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2015/01/25/Swift之字符串和字符/"
           data-title="Swift之字符串和字符" data-url="http://lynchwong.com/2015/01/25/Swift之字符串和字符/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="Lynch Wong" />
          <p class="site-author-name" itemprop="name">Lynch Wong</p>
          <p class="site-description motion-element" itemprop="description">I WILL.</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">141</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">49</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/LynchWong" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串字面量-String-Literals"><span class="nav-number">1.</span> <span class="nav-text">字符串字面量(String Literals)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化空字符串-Initializing-an-Empty-String"><span class="nav-number">2.</span> <span class="nav-text">初始化空字符串 (Initializing an Empty String)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串可变性-String-Mutability"><span class="nav-number">3.</span> <span class="nav-text">字符串可变性 (String Mutability)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串是值类型-Strings-Are-Value-Types"><span class="nav-number">4.</span> <span class="nav-text">字符串是值类型(Strings Are Value Types)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用字符-Working-with-Characters"><span class="nav-number">5.</span> <span class="nav-text">使用字符(Working with Characters)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#连接字符串和字符-Concatenating-Strings-and-Characters"><span class="nav-number">6.</span> <span class="nav-text">连接字符串和字符 (Concatenating Strings and Characters)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串插值-String-Interpolation"><span class="nav-number">7.</span> <span class="nav-text">字符串插值 (String Interpolation)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unicode"><span class="nav-number">8.</span> <span class="nav-text">Unicode</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Unicode-标量-Unicode-Scalars"><span class="nav-number">8.1.</span> <span class="nav-text">Unicode 标量(Unicode Scalars)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串字面量的特殊字符-Special-Characters-in-String-Literals"><span class="nav-number">8.2.</span> <span class="nav-text">字符串字面量的特殊字符 (Special Characters in String Literals)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可扩展的字形群集-Extended-Grapheme-Clusters"><span class="nav-number">8.3.</span> <span class="nav-text">可扩展的字形群集(Extended Grapheme Clusters)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算字符数量-Counting-Characters"><span class="nav-number">9.</span> <span class="nav-text">计算字符数量 (Counting Characters)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问和修改字符串-Accessing-and-Modifying-a-String"><span class="nav-number">10.</span> <span class="nav-text">访问和修改字符串 (Accessing and Modifying a String)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串索引-String-Indices"><span class="nav-number">10.1.</span> <span class="nav-text">字符串索引 (String Indices)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#插入和删除-Inserting-and-Removing"><span class="nav-number">10.2.</span> <span class="nav-text">插入和删除 (Inserting and Removing)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#比较字符串"><span class="nav-number">11.</span> <span class="nav-text">比较字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串-字符相等-String-and-Character-Equality"><span class="nav-number">11.1.</span> <span class="nav-text">字符串/字符相等 (String and Character Equality)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#前缀-后缀相等"><span class="nav-number">11.2.</span> <span class="nav-text">前缀/后缀相等</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串的-Unicode-表示形式-Unicode-Representations-of-Strings"><span class="nav-number">12.</span> <span class="nav-text">字符串的 Unicode 表示形式(Unicode Representations of Strings)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#UTF-8-表示"><span class="nav-number">12.1.</span> <span class="nav-text">UTF-8 表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UTF-16-表示"><span class="nav-number">12.2.</span> <span class="nav-text">UTF-16 表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unicode-标量表示-Unicode-Scalars-Representation"><span class="nav-number">12.3.</span> <span class="nav-text">Unicode 标量表示 (Unicode Scalars Representation)</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lynch Wong</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"nobodyknows"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  

  

</body>
</html>
