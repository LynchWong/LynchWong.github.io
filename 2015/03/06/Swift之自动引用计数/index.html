<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Swift," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="Swift 使用自动引用计数(ARC)机制来跟踪和管理你的应用程序的内存。通常情况下,Swift 的内存管理机制会一直起着作用,你无须自己来考虑内存的管理。ARC 会在类的实例不再被使用时,自动释放其占用的内存。
然而,在少数情况下,ARC 为了能帮助你管理内存,需要更多的关于你的代码之间关系的信息。本章描述了这些情况,并且为你示范怎样启用 ARC 来管理你的应用程序的内存。
注意: 引用计数仅仅">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift之自动引用计数">
<meta property="og:url" content="http://lynchwong.com/2015/03/06/Swift之自动引用计数/index.html">
<meta property="og:site_name" content="Nobodyknows+ 2.0">
<meta property="og:description" content="Swift 使用自动引用计数(ARC)机制来跟踪和管理你的应用程序的内存。通常情况下,Swift 的内存管理机制会一直起着作用,你无须自己来考虑内存的管理。ARC 会在类的实例不再被使用时,自动释放其占用的内存。
然而,在少数情况下,ARC 为了能帮助你管理内存,需要更多的关于你的代码之间关系的信息。本章描述了这些情况,并且为你示范怎样启用 ARC 来管理你的应用程序的内存。
注意: 引用计数仅仅">
<meta property="og:image" content="http://lynchwong.com/img/iOSARC/1.png">
<meta property="og:image" content="http://lynchwong.com/img/iOSARC/2.png">
<meta property="og:image" content="http://lynchwong.com/img/iOSARC/3.png">
<meta property="og:image" content="http://lynchwong.com/img/iOSARC/4.png">
<meta property="og:image" content="http://lynchwong.com/img/iOSARC/5.png">
<meta property="og:image" content="http://lynchwong.com/img/iOSARC/6.png">
<meta property="og:image" content="http://lynchwong.com/img/iOSARC/7.png">
<meta property="og:image" content="http://lynchwong.com/img/iOSARC/8.png">
<meta property="og:image" content="http://lynchwong.com/img/iOSARC/9.png">
<meta property="og:image" content="http://lynchwong.com/img/iOSARC/10.png">
<meta property="og:updated_time" content="2016-06-01T12:59:20.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Swift之自动引用计数">
<meta name="twitter:description" content="Swift 使用自动引用计数(ARC)机制来跟踪和管理你的应用程序的内存。通常情况下,Swift 的内存管理机制会一直起着作用,你无须自己来考虑内存的管理。ARC 会在类的实例不再被使用时,自动释放其占用的内存。
然而,在少数情况下,ARC 为了能帮助你管理内存,需要更多的关于你的代码之间关系的信息。本章描述了这些情况,并且为你示范怎样启用 ARC 来管理你的应用程序的内存。
注意: 引用计数仅仅">
<meta name="twitter:image" content="http://lynchwong.com/img/iOSARC/1.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>

  <title> Swift之自动引用计数 | Nobodyknows+ 2.0 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Nobodyknows+ 2.0</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">iOS、Go</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Swift之自动引用计数
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2015-03-06T09:08:55+08:00" content="2015-03-06">
              2015-03-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/03/06/Swift之自动引用计数/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/03/06/Swift之自动引用计数/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
              &nbsp; | &nbsp;
              <span class="page-pv"><i class="fa fa-file-o"></i>
              <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
              </span>
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Swift 使用自动引用计数(ARC)机制来跟踪和管理你的应用程序的内存。通常情况下,Swift 的内存管理机制会一直起着作用,你无须自己来考虑内存的管理。ARC 会在类的实例不再被使用时,自动释放其占用的内存。</p>
<p>然而,在少数情况下,ARC 为了能帮助你管理内存,需要更多的关于你的代码之间关系的信息。本章描述了这些情况,并且为你示范怎样启用 ARC 来管理你的应用程序的内存。</p>
<p>注意: 引用计数仅仅应用于类的实例。结构体和枚举类型是值类型,不是引用类型,也不是通过引用的方式存储和传递。</p>
<h2 id="自动引用计数的工作机制"><a href="#自动引用计数的工作机制" class="headerlink" title="自动引用计数的工作机制"></a>自动引用计数的工作机制</h2><p>当你每次创建一个类的新的实例的时候,ARC 会分配一大块内存用来储存实例的信息。内存中会包含实例的类型信息,以及这个实例所有相关属性的值。</p>
<p>此外,当实例不再被使用时,ARC 释放实例所占用的内存,并让释放的内存能挪作他用。这确保了不再被使用的实例,不会一直占用内存空间。</p>
<p>然而,当 ARC 收回和释放了正在被使用中的实例,该实例的属性和方法将不能再被访问和调用。实际上,如果你试图访问这个实例,你的应用程序很可能会崩溃。</p>
<p>为了确保使用中的实例不会被销毁,ARC 会跟踪和计算每一个实例正在被多少属性,常量和变量所引用。哪怕实例的引用数为1,ARC都不会销毁这个实例。</p>
<p>为了使上述成为可能,无论你将实例赋值给属性、常量或变量,它们都会创建此实例的强引用。之所以称之为“强”引用,是因为它会将实例牢牢的保持住,只要强引用还在,实例是不允许被销毁的。</p>
<h2 id="自动引用计数实践"><a href="#自动引用计数实践" class="headerlink" title="自动引用计数实践"></a>自动引用计数实践</h2><p>下面的例子展示了自动引用计数的工作机制。例子以一个简单的 Person 类开始,并定义了一个叫 name 的常量 属性:</p>
<pre><code>class Person {
    let name: String
    init(name: String) {
        self.name = name
        println(&quot;\(name) is being initialized&quot;)
    }
    deinit {
        println(&quot;\(name) is being deinitialized&quot;)
    }
}
</code></pre><p>Person 类有一个构造函数,此构造函数为实例的 name 属性赋值,并打印一条消息以表明初始化过程生效。 Person 类也拥有一个析构函数,这个析构函数会在实例被销毁时打印一条消息。</p>
<p>接下来的代码片段定义了三个类型为 Person? 的变量,用来按照代码片段中的顺序,为新的 Person 实例建立多个引用。由于这些变量是被定义为可选类型( Person? ,而不是 Person ),它们的值会被自动初始化为 nil ,目前还不会引用到 Person 类的实例。</p>
<pre><code>var reference1: Person?
var reference2: Person?
var reference3: Person?
</code></pre><p>现在你可以创建 Person 类的新实例,并且将它赋值给三个变量中的一个:</p>
<pre><code>reference1 = Person(name: &quot;John Appleseed&quot;)
// prints &quot;John Appleseed is being initialized&quot;
</code></pre><p>应当注意到当你调用 Person 类的构造函数的时候,”John Appleseed is being initialized”会被打印出来。由此可以确定构造函数被执行。</p>
<p>由于 Person 类的新实例被赋值给了 reference1 变量,所以 reference1 到 Person 类的新实例之间建立了一个强引用。正是因为这一个强引用,ARC 会保证 Person 实例被保持在内存中不被销毁。</p>
<p>如果你将同一个 Person 实例也赋值给其他两个变量,该实例又会多出两个强引用:</p>
<pre><code>reference2 = reference1
reference3 = reference1
</code></pre><p>现在这一个 Person 实例已经有三个强引用了。</p>
<p>如果你通过给其中两个变量赋值 nil 的方式断开两个强引用(包括最先的那个强引用),只留下一个强引用, Person 实例不会被销毁:</p>
<pre><code>reference1 = nil
reference2 = nil
</code></pre><p>在你清楚地表明不再使用这个 Person 实例时,即第三个也就是最后一个强引用被断开时,ARC 会销毁它。</p>
<pre><code>reference3 = nil
// prints &quot;John Appleseed is being deinitialized&quot;
</code></pre><h2 id="类实例之间的循环强引用"><a href="#类实例之间的循环强引用" class="headerlink" title="类实例之间的循环强引用"></a>类实例之间的循环强引用</h2><p>在上面的例子中,ARC 会跟踪你所新创建的 Person 实例的引用数量,并且会在 Person 实例不再被需要时销 毁它。</p>
<p>然而,我们可能会写出一个类实例的强引用数永远不能变成0的代码。如果两个类实例互相持有对方的强引用,因而每个实例都让对方一直存在,就是这种情况。这就是所谓的循环强引用。</p>
<p>你可以通过定义类之间的关系为弱引用或无主引用,以替代强引用,从而解决循环强引用的问题。具体的过程在 解决类实例之间的循环强引用 中有描述。不管怎样,在你学习怎样解决循环强引用之前,很有必要了解一下它是怎样产生的。</p>
<p>下面展示了一个不经意产生循环强引用的例子。例子定义了两个类: Person 和 Apartment ,用来建模公寓和它其中的居民:</p>
<pre><code>class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { println(&quot;\(name) is being deinitialized&quot;) }
}

class Apartment {
    let number: Int
    init(number: Int) { self.number = number }
    var tenant: Person?
    deinit { println(&quot;Apartment #\(number) is being deinitialized&quot;) }
}
</code></pre><p>每一个 Person 实例有一个类型为 String ,名字为 name 的属性,并有一个可选的初始化为 nil 的 属性。 apartment 属性是可选的,因为一个人并不总是拥有公寓。</p>
<p>类似的,每个 Apartment 实例有一个叫 number ,类型为 Int 的属性,并有一个可选的初始化为 nil 的 tenant 属性。 tenant 属性是可选的,因为一栋公寓并不总是有居民。</p>
<p>这两个类都定义了析构函数,用以在类实例被析构的时候输出信息。这让你能够知晓 Person 和 Apartment 的实 例是否像预期的那样被销毁。</p>
<p>接下来的代码片段定义了两个可选类型的变量 john 和 number73 ,并分别被设定为下面的 Apartment 和 Person 的实例。这两个变量都被初始化为 nil ,这正是可选的优点:</p>
<pre><code>var john: Person?
var number73: Apartment?
</code></pre><p>现在你可以创建特定的 Person 和 Apartment 实例并将赋值给 john 和 number73 变量:</p>
<pre><code>john = Person(name: &quot;John Appleseed&quot;)
number73 = Apartment(number: 73)
</code></pre><p>在两个实例被创建和赋值后,下图表现了强引用的关系。变量 john 现在有一个指向 Person 实例的强引用,而 变量 number73 有一个指向 Apartment 实例的强引用:</p>
<p><img src="/img/iOSARC/1.png" alt="alt text"></p>
<p>现在你能够将这两个实例关联在一起,这样人就能有公寓住了,而公寓也有了房客。注意感叹号是用来展开和访 问可选变量 john 和 number73 中的实例,这样实例的属性才能被赋值:</p>
<pre><code>john!.apartment = number73
number73!.tenant = john
</code></pre><p>在将两个实例联系在一起之后,强引用的关系如图所示:</p>
<p><img src="/img/iOSARC/2.png" alt="alt text"></p>
<p>不幸的是,这两个实例关联后会产生一个循环强引用。   实例现在有了一个指向 实例的强引 用,而   实例也有了一个指向   实例的强引用。因此,当你断开 和 变量所持 有的强引用时,引用计数并不会降为 0,实例也不会被 ARC 销毁:</p>
<pre><code>john = nil
number73 = nil
</code></pre><p>注意,当你把这两个变量设为 nil 时,没有任何一个析构函数被调用。循环强引用会一直阻止 Person 和 Apartment 类实例的销毁,这就在你的应用程序中造成了内存泄漏。</p>
<p>在你将 john 和 number73 赋值为 nil 后,强引用关系如下图:</p>
<p><img src="/img/iOSARC/3.png" alt="alt text"></p>
<p>Person 和 Apartment 实例之间的强引用关系保留了下来并且不会被断开。</p>
<h2 id="解决实例之间的循环强引用"><a href="#解决实例之间的循环强引用" class="headerlink" title="解决实例之间的循环强引用"></a>解决实例之间的循环强引用</h2><p>Swift 提供了两种办法用来解决你在使用类的属性时所遇到的循环强引用问题:弱引用(weak reference)和无 主引用(unowned reference)。</p>
<p>弱引用和无主引用允许循环引用中的一个实例引用另外一个实例而不保持强引用。这样实例能够互相引用而不产生循环强引用。</p>
<p>对于生命周期中会变为 nil 的实例使用弱引用。相反地,对于初始化赋值后再也不会被赋值为 nil 的实例,使用无主引用。</p>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>弱引用不会对其引用的实例保持强引用,因而不会阻止 ARC 销毁被引用的实例。这个特性阻止了引用变为循环强引用。声明属性或者变量时,在前面加上 weak 关键字表明这是一个弱引用。</p>
<p>在实例的生命周期中,如果某些时候引用没有值,那么弱引用可以避免循环强引用。如果引用总是有值,则可以使用无主引用,在无主引用中有描述。在上面 Apartment 的例子中,一个公寓的生命周期中,有时是没有“居民”的,因此适合使用弱引用来解决循环强引用。</p>
<p>注意: 弱引用必须被声明为变量,表明其值能在运行时被修改。弱引用不能被声明为常量。</p>
<p>因为弱引用可以没有值,你必须将每一个弱引用声明为可选类型。在 Swift 中,推荐使用可选类型描述可能没有值的类型。</p>
<p>因为弱引用不会保持所引用的实例,即使引用存在,实例也有可能被销毁。因此,ARC 会在引用的实例被销毁后 自动将其赋值为 nil 。你可以像其他可选值一样,检查弱引用的值是否存在,你将永远不会访问已销毁的实例的引 用。</p>
<p>下面的例子跟上面 Person 和 Apartment 的例子一致,但是有一个重要的区别。这一次, Apartment 的 tenant 属性被声明为弱引用:</p>
<pre><code>class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { println(&quot;\(name) is being deinitialized&quot;) }
}

class Apartment {
    let number: Int
    init(number: Int) { self.number = number }
    weak var tenant: Person?
    deinit { println(&quot;Apartment #\(number) is being deinitialized&quot;) }
}
</code></pre><p>然后跟之前一样,建立两个变量( john 和 number73 )之间的强引用,并关联两个实例:</p>
<pre><code>var john: Person?
var number73: Apartment?

john = Person(name: &quot;John Appleseed&quot;)
number73 = Apartment(number: 73)

john!.apartment = number73
number73!.tenant = john
</code></pre><p>现在,两个关联在一起的实例的引用关系如下图所示:</p>
<p><img src="/img/iOSARC/4.png" alt="alt text"></p>
<p>Person 实例依然保持对 Apartment 实例的强引用,但是 Apartment 实例只是对 Person 实例的弱引用。这意味着当你断开 john 变量所保持的强引用时,再也没有指向 Person 实例的强引用了:</p>
<p><img src="/img/iOSARC/5.png" alt="alt text"></p>
<p>由于再也没有指向 Person 实例的强引用,该实例会被销毁:</p>
<pre><code>john = nil
// prints &quot;John Appleseed is being deinitialized&quot;
</code></pre><p>唯一剩下的指向 Apartment 实例的强引用来自于变量 number73 。如果你断开这个强引用,再也没有指向 Apartment 实例的强引用了:</p>
<p><img src="/img/iOSARC/6.png" alt="alt text"></p>
<p>由于再也没有指向 Apartment 实例的强引用,该实例也会被销毁:</p>
<pre><code>number73 = nil
// prints &quot;Apartment #73 is being deinitialized&quot;
</code></pre><p>上面的两段代码展示了变量 john 和 number73 在被赋值为 nil 后, Person 实例和 Apartment 实例的析构函数都打印出“销毁”的信息。这证明了引用循环被打破了。</p>
<h3 id="无主引用"><a href="#无主引用" class="headerlink" title="无主引用"></a>无主引用</h3><p>和弱引用类似,无主引用不会牢牢保持住引用的实例。和弱引用不同的是,无主引用是永远有值的。因此,无主引用总是被定义为非可选类型(non-optional type)。你可以在声明属性或者变量时,在前面加上关键字 unowned 表示这是一个无主引用。</p>
<p>由于无主引用是非可选类型,你不需要在使用它的时候将它展开。无主引用总是可以被直接访问。不过 ARC 无法在实例被销毁后将无主引用设为 nil ,因为非可选类型的变量不允许被赋值为 nil 。</p>
<p>注意: 如果你试图在实例被销毁后,访问该实例的无主引用,会触发运行时错误。使用无主引用,你必须确保引用始终 指向一个未销毁的实例。<br>还需要注意的是如果你试图访问实例已经被销毁的无主引用,Swift 确保程序会直接崩溃,而不会发生无法预期的行为。所以你应当避免这样的事情发生。</p>
<p>下面的例子定义了两个类, Customer 和 CreditCard ,模拟了银行客户和客户的信用卡。这两个类中,每一个都将另外一个类的实例作为自身的属性。这种关系可能会造成循环强引用。</p>
<p>Customer 和 CreditCard 之间的关系与前面弱引用例子中 Apartment 和 Person 的关系略微不同。在这个数据模型中,一个客户可能有或者没有信用卡,但是一张信用卡总是关联着一个客户。为了表示这种关系, Customer 类有一个可选类型的 card 属性,但是 CreditCard 类有一个非可选类型的 customer 属性。</p>
<p>此外,只能通过将一个 number 值和 customer 实例传递给 CreditCard 构造函数的方式来创建 CreditCard 实例。这样可以确保当创建 CreditCard 实例时总是有一个 customer 实例与之关联。</p>
<p>由于信用卡总是关联着一个客户,因此将 customer 属性定义为无主引用,用以避免循环强引用:</p>
<pre><code>class Customer {
    let name: String
    var card: CreditCard?
    init(name: String) {
        self.name = name
    }
    deinit { println(&quot;\(name) is being deinitialized&quot;) }
}

class CreditCard {
    let number: UInt64
    unowned let customer: Customer
    init(number: UInt64, customer: Customer) {
        self.number = number
        self.customer = customer
    }
    deinit { println(&quot;Card #\(number) is being deinitialized&quot;) }
}
</code></pre><p>注意: CreditCard 类的 number 属性被定义为 UInt64 类型而不是 Int 类型,以确保 number 属性的存储量在32位和64位系统上都能足够容纳16位的卡号。</p>
<p>下面的代码片段定义了一个叫 john 的可选类型 Customer 变量,用来保存某个特定客户的引用。由于是可选类型,所以变量被初始化为 nil 。</p>
<pre><code>var john: Customer?
</code></pre><p>现在你可以创建 Customer 类的实例,用它初始化 CreditCard 实例,并将新创建的 CreditCard 实例赋值为客 户的 card 属性。</p>
<pre><code>john = Customer(name: &quot;John Appleseed&quot;)
john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)
</code></pre><p>在你关联两个实例后,它们的引用关系如下图所示:</p>
<p><img src="/img/iOSARC/7.png" alt="alt text"></p>
<p>Customer 实例持有对 CreditCard 实例的强引用,而 CreditCard 实例持有对 Customer 实例的无主引用。 </p>
<p>由于 customer 的无主引用,当你断开 john 变量持有的强引用时,再也没有指向 Customer 实例的强引用了:</p>
<p><img src="/img/iOSARC/8.png" alt="alt text"></p>
<p>由于再也没有指向 Customer 实例的强引用,该实例被销毁了。其后,再也没有指向 CreditCard 实例的强引用,该实例也随之被销毁了:</p>
<pre><code>john = nil
// prints &quot;John Appleseed is being deinitialized&quot;
// prints &quot;Card #1234567890123456 is being deinitialized&quot;
</code></pre><p>最后的代码展示了在 john 变量被设为 nil 后 Customer 实例和 CreditCard 实例的构造函数都打印出了“销毁”的信息。</p>
<h3 id="无主引用以及隐式解析可选属性"><a href="#无主引用以及隐式解析可选属性" class="headerlink" title="无主引用以及隐式解析可选属性"></a>无主引用以及隐式解析可选属性</h3><p>上面弱引用和无主引用的例子涵盖了两种常用的需要打破循环强引用的场景。</p>
<p>Person 和 Apartment 的例子展示了两个属性的值都允许为 nil ,并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。</p>
<p>Customer 和 CreditCard 的例子展示了一个属性的值允许为 nil ,而另一个属性的值不允许为 nil ,这也可能会产生循环强引用。这种场景最适合通过无主引用来解决。</p>
<p>然而,存在着第三种场景,在这种场景中,两个属性都必须有值,并且初始化完成后永远不会为 nil 。在这种场景中,需要一个类使用无主属性,而另外一个类使用隐式解析可选属性。</p>
<p>这使两个属性在初始化完成后能被直接访问(不需要可选展开),同时避免了循环引用。这一节将为你展示如何建立这种关系。</p>
<p>下面的例子定义了两个类, Country 和 City ,每个类将另外一个类的实例保存为属性。在这个模型中,每个国家必须有首都,每个城市必须属于一个国家。为了实现这种关系, Country 类拥有一个 capitalCity 属性,而 City 类有一个 country 属性:</p>
<pre><code>class Country {
    let name: String
    var capitalCity: City!
    init(name: String, capitalName: String) {
        self.name = name
        self.capitalCity = City(name: capitalName, country: self)
    }
}

class City {
    let name: String
    unowned let country: Country
    init(name: String, country: Country) {
        self.name = name
        self.country = country
    }
}
</code></pre><p>为了建立两个类的依赖关系, City 的构造函数有一个 Country 实例的参数,并且将实例保存为 country 属性。</p>
<p>Country 的构造函数调用了 City 的构造函数。然而,只有 Country 的实例完全初始化完后, Country 的构造 函数才能把 self 传给 City 的构造函数。(在两段式构造过程 中有具体描述)</p>
<p>为了满足这种需求,通过在类型结尾处加上感叹号( City! )的方式,将 Country 的 capitalCity 属性声明为隐 式解析可选类型的属性。这表示像其他可选类型一样, capitalCity 属性的默认值为 nil ,但是不需要展开它的值 就能访问它。(在隐式解析可选类型 中有描述)</p>
<p>由于 capitalCity 默认值为 nil ,一旦 Country 的实例在构造函数中给 name 属性赋值后,整个初始化过程就完成了。这代表一旦 name 属性被赋值后, Country 的构造函数就能引用并传递隐式的 self 。 Country 的构造函 数在赋值 capitalCity 时,就能将 self 作为参数传递给 City 的构造函数。</p>
<p>以上的意义在于你可以通过一条语句同时创建 Country 和 City 的实例,而不产生循环强引用,并且capitalCity的属性能被直接访问,而不需要通过感叹号来展开它的可选值:</p>
<pre><code>var country = Country(name: &quot;Canada&quot;, capitalName: &quot;Ottawa&quot;)
println(&quot;\(country.name)&apos;s capital city is called \(country.capitalCity.name)&quot;)
// prints &quot;Canada&apos;s capital city is called Ottawa&quot;
</code></pre><p>在上面的例子中,使用隐式解析可选值的意义在于满足了两个类构造函数的需求。 capitalCity 属性在初始化完成后,能像非可选值一样使用和存取同时还避免了循环强引用。</p>
<h2 id="闭包产生的强引用环"><a href="#闭包产生的强引用环" class="headerlink" title="闭包产生的强引用环"></a>闭包产生的强引用环</h2><p>前面我们看到了循环强引用是在两个类实例属性互相保持对方的强引用时产生的,还知道了如何用弱引用和无主引用来打破这些循环强引用。</p>
<p>循环强引用还会发生在当你将一个闭包赋值给类实例的某个属性,并且这个闭包体中又使用了这个类实例。这个闭包体中可能访问了实例的某个属性,例如 self.someProperty ,或者闭包中调用了实例的某个方法,例如 sel f.someMethod 。这两种情况都导致了闭包 “捕获” self ,从而产生了循环强引用。</p>
<p>循环强引用的产生,是因为闭包和类相似,都是引用类型。当你把一个闭包赋值给某个属性时,你也把一个引用赋值给了这个闭包。实质上,这跟之前的问题是一样的-两个强引用让彼此一直有效。但是,和两个类实例不同,这次一个是类实例,另一个是闭包。</p>
<p>Swift 提供了一种优雅的方法来解决这个问题,称之为闭包捕获列表(closuer capture list)。同样的,在学习如何用闭包捕获列表破坏循环强引用之前,先来了解一下这里的循环强引用是如何产生的,这对我们很有帮助。</p>
<p>下面的例子为你展示了当一个闭包引用了 self 后是如何产生一个循环强引用的。例子中定义了一个叫 HTMLElement 的类,用一种简单的模型表示 HTML 中的一个单独的元素:</p>
<pre><code>class HTMLElement {

    let name: String
    let text: String?

    lazy var asHTML: () -&gt; String = {
        if let text = self.text {
            return &quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;
        } else {
            return &quot;&lt;\(self.name) /&gt;&quot;
        }
    }

    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
    }

    deinit {
        println(&quot;\(name) is being deinitialized&quot;)
    }
}
</code></pre><p>HTMLElement 类定义了一个 name 属性来表示这个元素的名称,例如代表段落的”p”,或者代表换行的”br”。HTMLElement 还定义了一个可选属性 text,用来设置和展现 HTML 元素的文本。</p>
<p>除了上面的两个属性, HTMLElement 还定义了一个 lazy 属性 asHTML 。这个属性引用了一个将 name 和 text 组合成 HTML 字符串片段的闭包。该属性是 Void -&gt; String 类型,或者可以理解为“一个没有参数,返回 St ring 的函数”。</p>
<p>默认情况下,闭包赋值给了 asHTML 属性,这个闭包返回一个代表 HTML 标签的字符串。如果 text 值存在,该标签就包含可选值 text ;如果 text 不存在,该标签就不包含文本。对于段落元素,根据 text 是 “some t ext” 还是 nil ,闭包会返回”</p><p>some text</p> “或者”<p> “。</p>
<p>可以像实例方法那样去命名、使用 asHTML 属性。然而,由于 asHTML 是闭包而不是实例方法,如果你想改变 特定元素的 HTML 处理的话,可以用自定义的闭包来取代默认值。</p>
<p>注意:asHTML 声明为 lazy 属性,因为只有当元素确实需要处理为HTML输出的字符串时,才需要使用 asHTML 。也就是说,在默认的闭包中可以使用 self ,因为只有当初始化完成以及 self 确实存在后,才能访问 lazy 属性。</p>
<p>HTMLElement 类只提供一个构造函数,通过 name 和 text (如果有的话)参数来初始化一个元素。该类也定义了一个析构函数,当 HTMLElement 实例被销毁时,打印一条消息。</p>
<p>下面的代码展示了如何用 HTMLElement 类创建实例并打印消息。</p>
<pre><code>var paragraph: HTMLElement? = HTMLElement(name: &quot;p&quot;, text: &quot;hello, world&quot;)
println(paragraph!.asHTML())
// prints &quot;&lt;p&gt;hello, world&lt;/p&gt;&quot;
</code></pre><p>注意:上面的 paragraph 变量定义为 可选HTMLElement ,因此我们可以赋值 nil 给它来演示循环强引用。</p>
<p>不幸的是,上面写的 HTMLElement 类产生了类实例和 asHTML 默认值的闭包之间的循环强引用。循环强引用如下图所示:</p>
<p><img src="/img/iOSARC/9.png" alt="alt text"></p>
<p>实例的 asHTML 属性持有闭包的强引用。但是,闭包在其闭包体内使用了 self (引用了 self.name 和 self.text),因此闭包捕获了 self ,这意味着闭包又反过来持有了 HTMLElement 实例的强引用。这样两个对象就产生 了循环强引用。(更多关于闭包捕获值的信息,请参考值捕获)。</p>
<p>注意:虽然闭包多次使用了 self ,它只捕获 HTMLElement 实例的一个强引用。</p>
<p>如果设置 paragraph 变量为 nil ,打破它持有的 HTMLElement 实例的强引用, HTMLElement 实例和它的闭 包都不会被销毁,也是因为循环强引用:</p>
<pre><code>paragraph = nil
</code></pre><p>注意 HTMLElementdeinitializer 中的消息并没有被打印,证明了 HTMLElement 实例并没有被销毁。</p>
<h2 id="解决闭包引起的循环强引用"><a href="#解决闭包引起的循环强引用" class="headerlink" title="解决闭包引起的循环强引用"></a>解决闭包引起的循环强引用</h2><p>在定义闭包时同时定义捕获列表作为闭包的一部分,通过这种方式可以解决闭包和类实例之间的循环强引用。捕获列表定义了闭包体内捕获一个或者多个引用类型的规则。跟解决两个类实例间的循环强引用一样,声明每个捕获的引用为弱引用或无主引用,而不是强引用。应当根据代码关系来决定使用弱引用还是无主引用。</p>
<p>注意:Swift 有如下要求:只要在闭包内使用 self 的成员,就要用 self.someProperty 或者 self.someMethod (而不只是 someProperty 或 someMethod )。这提醒你可能会一不小心就捕获了 self 。</p>
<h3 id="定义捕获列表"><a href="#定义捕获列表" class="headerlink" title="定义捕获列表"></a>定义捕获列表</h3><p>捕获列表中的每一项都由一对元素组成,一个元素是 weak 或 unowned 关键字,另一个元素是类实例的引用(如 self )或初始化过的变量(如 delegate = self.delegate! )。这些项在方括号中用逗号分开。</p>
<p>如果闭包有参数列表和返回类型,把捕获列表放在它们前面:</p>
<pre><code>lazy var someClosure: (Int, String) -&gt; String = {
    [unowned self] (index: Int, stringToProcess: String) -&gt; String in
    // closure body goes here
}
</code></pre><p>如果闭包没有指明参数列表或者返回类型,即它们会通过上下文推断,那么可以把捕获列表和关键字 in 放在闭包 最开始的地方:</p>
<pre><code>lazy var someClosure: () -&gt; String = {
    [unowned self] in
    // closure body goes here
}
</code></pre><h3 id="弱引用和无主引用"><a href="#弱引用和无主引用" class="headerlink" title="弱引用和无主引用"></a>弱引用和无主引用</h3><p>在闭包和捕获的实例总是互相引用时并且总是同时销毁时,将闭包内的捕获定义为无主引用。</p>
<p>相反的,在被捕获的引用可能会变为 nil 时,将闭包内的捕获定义为弱引用。弱引用总是可选类型,并且当引用的实例被销毁后,弱引用的值会自动置为 nil 。这使我们可以在闭包体内检查它们是否存在。</p>
<p>注意:如果被捕获的引用绝对不会变为 nil ,应该用无主引用,而不是弱引用。</p>
<p>前面的 HTMLElement 例子中,无主引用是正确的解决循环强引用的方法。这样编写 HTMLElement 类来避免 循环强引用:</p>
<pre><code>class HTMLElement {

    let name: String
    let text: String?

    lazy var asHTML: () -&gt; String = {
        [unowned self] in
        if let text = self.text {
            return &quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;
        } else {
            return &quot;&lt;\(self.name) /&gt;&quot;
        }
    }

    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
    }

    deinit {
        println(&quot;\(name) is being deinitialized&quot;)
    }
}
</code></pre><p>上面的 HTMLElement 实现和之前的实现一致,除了在 asHTML 闭包中多了一个捕获列表。这里,捕获列表 是 [unowned self] ,表示“用无主引用而不是强引用来捕获 self ”。</p>
<p>和之前一样,我们可以创建并打印 HTMLElement 实例:</p>
<pre><code>var paragraph: HTMLElement? = HTMLElement(name: &quot;p&quot;, text: &quot;hello, world&quot;)
println(paragraph!.asHTML())
// prints &quot;&lt;p&gt;hello, world&lt;/p&gt;&quot;
</code></pre><p>使用捕获列表后引用关系如下图所示:</p>
<p><img src="/img/iOSARC/10.png" alt="alt text"></p>
<p>这一次,闭包以无主引用的形式捕获 self ,并不会持有 HTMLElement 实例的强引用。如果将 paragraph 赋值 为 nil , HTMLElement 实例将会被销毁,并能看到它的析构函数打印出的消息。</p>
<pre><code>paragraph = nil
// prints &quot;p is being deinitialized&quot;
</code></pre>
      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/images/wechat-reward-image.png" alt="Lynch Wong WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/images/alipay-reward-image.png" alt="Lynch Wong Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Swift/" rel="tag">#Swift</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/03/05/Swift之析构过程/" rel="next" title="Swift之析构过程">
                <i class="fa fa-chevron-left"></i> Swift之析构过程
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/03/06/Swift之可空链式调用/" rel="prev" title="Swift之可空链式调用">
                Swift之可空链式调用 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="2015/03/06/Swift之自动引用计数/"
     data-title="Swift之自动引用计数"
     data-content=""
     data-url="http://lynchwong.com/2015/03/06/Swift之自动引用计数/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2015/03/06/Swift之自动引用计数/"
           data-title="Swift之自动引用计数" data-url="http://lynchwong.com/2015/03/06/Swift之自动引用计数/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="Lynch Wong" />
          <p class="site-author-name" itemprop="name">Lynch Wong</p>
          <p class="site-description motion-element" itemprop="description">I WILL.</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">132</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">39</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/LynchWong" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#自动引用计数的工作机制"><span class="nav-number">1.</span> <span class="nav-text">自动引用计数的工作机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自动引用计数实践"><span class="nav-number">2.</span> <span class="nav-text">自动引用计数实践</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类实例之间的循环强引用"><span class="nav-number">3.</span> <span class="nav-text">类实例之间的循环强引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解决实例之间的循环强引用"><span class="nav-number">4.</span> <span class="nav-text">解决实例之间的循环强引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#弱引用"><span class="nav-number">4.1.</span> <span class="nav-text">弱引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无主引用"><span class="nav-number">4.2.</span> <span class="nav-text">无主引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无主引用以及隐式解析可选属性"><span class="nav-number">4.3.</span> <span class="nav-text">无主引用以及隐式解析可选属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭包产生的强引用环"><span class="nav-number">5.</span> <span class="nav-text">闭包产生的强引用环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解决闭包引起的循环强引用"><span class="nav-number">6.</span> <span class="nav-text">解决闭包引起的循环强引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义捕获列表"><span class="nav-number">6.1.</span> <span class="nav-text">定义捕获列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#弱引用和无主引用"><span class="nav-number">6.2.</span> <span class="nav-text">弱引用和无主引用</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lynch Wong</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"nobodyknows"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  

  

</body>
</html>
